<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1//EN" [

<!-- Base URL for the reference & tutorial documentation -->
<!ENTITY refdoc "http://nltk.sourceforge.net/ref">
<!ENTITY tutdoc "http://nltk.sourceforge.net/tutorial">

<!-- Index -->
<!ENTITY index SYSTEM "index.xml">

<!-- Prompts for Python code samples -->
<!ENTITY prompt "<prompt>&gt;</prompt><prompt>&gt;</prompt><prompt>&gt;</prompt>">
<!ENTITY prompt2 "<prompt>...</prompt>">
]>

<article>
  
  <articleinfo>
    <author><firstname>Edward</firstname><surname>Loper</surname></author>
    <authorinitials>edl</authorinitials>
    <title>NLTK Tutorial: Probability</title>
  </articleinfo>

  <section id="basics"> <title> Experiments and Samples </title>

    <indexterm><primary>experiment</primary></indexterm>
    <para> The <literal>nltk.probability</literal> module can be used
    to model probablistic phenomena.  Most probablistic phenomena can
    be thought of as experiments.  An
    <glossterm>experiment</glossterm> is any process which leads to a
    well-defined outcome.  For example, rolling a die is an experiment
    whose possible outcomes are 1, 2, 3, 4, 5, and 6.
    </para>
    
    <indexterm><primary>sample</primary></indexterm>
    <para> A <glossterm>sample</glossterm> is any possible outcome of
    a given experiment.  In <literal>nltk.probability</literal>, any
    immutable Python value or object can be a sample.  Typical samples
    are strings, integers, Tokens, and tuples.  We can use a simple
    Python procedure to define the experiment of rolling a die; its
    samples are 1, 2, 3, 4, 5, and 6: </para>

<programlisting>
    &prompt;<command> import random</command>
    &prompt;<command> def roll():</command>
    <prompt>...</prompt><command>     return random.choice( [1, 2, 3, 4, 5, 6] )</command>
    &prompt;<command> roll()</command>
    4
</programlisting>

  </section> <!-- Experiments and Samples -->

  <section id="FreqDist"> <title> Frequency Distributions </title>

    <para> A frequency distribution records the number of times each
    outcome of an experiment has occured.  For example, a frequency
    distribution could be used to record the frequency of each word
    type in a document.  Frequency distributions are encoded by the
    <ulink url="&refdoc;/nltk.probability.FreqDist.html"
    ><literal>FreqDist</literal></ulink> class, which is defined by the
    <ulink url="&refdoc;/nltk.probability.html"
    ><literal>nltk.probability</literal> module</ulink>. </para>

    <section id="FreqDist.constructing"> 
      <title> Constructing a Frequency Distribution </title>

      <para> The <ulink
      url="&refdoc;/nltk.probability.FreqDist.html#__init__"
      ><literal>FreqDist</literal> constructor</ulink> creates a new
      empty frequency distribution: </para>

<programlisting>
    &prompt;<command> freq_dist = FreqDist()</command>
    &lt;FreqDist with 0 outcomes&gt;
</programlisting>

      <para> Frequency distributions are generally initialized by
      repeatedly running an experiment, and incrementing the count for
      a sample every time it is an outcome of the experiment.  For
      example, the following code will produce a frequency
      distribution that records how often each word type occurs in a
      text: </para>

<programlisting>
    &prompt;<command> freq_dist = FreqDist()</command>
    &prompt;<command> for token in document:</command>
    &prompt2;<command>     freq_dist.inc(token.type())</command>
</programlisting>

    </section> <!-- Constructing a FreqDist -->

    <section id="FreqDist.using"> 
      <title> Using a Frequency Distribution </title>

      <para> Once we construct a frequency distribution that records
      the outcomes of an experiment, we can use it to examine a number
      of interesting properties of the experiment.  This section
      describes the most important accessors that are defined for
      frequency distributions. </para>

      <para> We can find the number of times a given sample occured
      with the <ulink url="&refdoc;/nltk.probability.FreqDist.html#count"
      ><literal>count</literal></ulink> method: 

<programlisting>
    <emphasis># How many times did "the" occur?</emphasis>
    &prompt;<command> freq_dist.count('the')</command>
    6
</programlisting>
</para>

      <para> The <ulink url="&refdoc;/nltk.probability.FreqDist.html#freq"
      ><literal>freq</literal></ulink> method returns the frequency of
      a given sample: 

<programlisting>
    <emphasis># What was the frequency of the word "the"?</emphasis>
    &prompt;<command> freq_dist.freq('the')</command>
    0.012
</programlisting>
</para>

      <para> We can find the total number of sample outcomes recorded
      by a frequency distribution with the <ulink
      url="&refdoc;/nltk.probability.FreqDist.html#N"
      ><literal>N</literal></ulink> method: 

<programlisting>
    <emphasis># How many words were counted? </emphasis>
    &prompt;<command> freq_dist.N()</command>
    500
</programlisting>
</para>

      <para> The <ulink
      url="&refdoc;/nltk.probability.FreqDist.html#samples"
      ><literal>samples</literal></ulink> method returns a list of all
      samples that have been recorded as outcomes by a frequency
      distribution: 

<programlisting>
    <emphasis># What words were encountered? </emphasis>
    &prompt;<command> freq_dist.samples()[:5]</command>
    ['happy', 'but', 'the', 'in', 'of']
</programlisting>
</para>

      <para> We can find the sample with the greatest number of
      outcomes with the <ulink
      url="&refdoc;/nltk.probability.FreqDist.html#max"
      ><literal>max</literal></ulink> method:

<programlisting>
    &prompt;<command> freq_dist.max()</command>
    <emphasis># What was the most common word? </emphasis>
    'the'
</programlisting>
</para>

      <para> See the reference documentation for <ulink
      url="&refdoc;/nltk.probability.FreqDist.html"
      ><literal>FreqDistI</literal></ulink> for more information on
      how to use frequency distributions.</para>
    </section> <!-- Using Frequency Distributions -->

    <section id="FreqDist.example"> 
      <title> Example: Word Lengths </title>

      <para> In this section, we use a <literal>FreqDist</literal> to
      examine the distribution of word lengths in a corpus.  In
      particular, we find the distribution of word lengths for... </para>

      <itemizedlist>
        <listitem><para>All words in a corpus.</para></listitem>
        <listitem><para>Words that end in vowels.  </para></listitem>
        <listitem><para>Words following words that end in
        vowels.</para></listitem>
      </itemizedlist>

      <para> In each case, we construct a frequency distribution whose
      samples are word lengths; and plot the results. </para>

      <para> To begin with, we load a corpus from a text file:</para>

<programlisting>
    &prompt;<command> corpus = open('corpus.txt').read() </command>
    &prompt;<command> tokens = WSTokenizer().tokenize(corpus) </command>
</programlisting>

      <section id="FreqDist.example.question1">
        <title> All words in a corpus </title>

        <para> To find the first distribution, we examine each token
        in the corpus, and find the length of its token.  This length
        is the "outcome" for our experiment, so we use
        <literal>inc()</literal> to increment its count in a frequency
        distribution. </para>

<programlisting>
    <emphasis># What is the distribution of word lengths in a corpus? </emphasis>
    &prompt;<command> freq_dist = FreqDist()</command>
    &prompt;<command> for token in tokens:</command>
    &prompt2;<command>     freq_dist.inc(len(token.type()))</command>
</programlisting>

        <para> To plot the results, we first create a sorted list of
        all word lengths that were encountered in the document.  We
        then construct a list of points, where the x coordinate is the
        word length, and the y coordinate is the frequency with which
        that word length is used: </para>

<programlisting>
    <emphasis># Plot the results. </emphasis>
    &prompt;<command> wordlens = freq_dist.samples() </command>
    &prompt;<command> wordlens.sort()</command>
    &prompt;<command> points = [(l, freq_dist.freq(l)) for l in wordlens]</command>
    &prompt;<command> Plot(points)</command>
</programlisting>
        
        <note> <para> We are currently using a fairly simple class to
        plot functions.  We will likely replace it with a more
        advanced plotting system in the future. </para> </note>

      </section> <!-- Question 1 -->

      <section id="FreqDist.example.question2">
        <title> Words ending in vowels  </title>

        <indexterm><primary>condition</primary></indexterm> <para> For
        the second distribution, we only care about word lengths for
        words that end in vowels.  This specification of which word
        lengths we care about is known as a
        <glossterm>condition</glossterm>.  In the next section, we
        will explore ways of encoding the frequency distributions for
        a single experiment under a variety of related
        conditions. </para>

        <para> To find the second distribution, we examine each token
        in the corpus.  If it ends in a vowel, then we increment the
        count for its length in a frequency distribution. </para>

<programlisting>
    <emphasis># For this example, we define vowels as "a", "e", "i", "o", and "u" </emphasis>
    &prompt;<command> VOWELS = ('a', 'e', 'i', 'o', 'u')</command>

    <emphasis># What is the distribution of word lengths for words that </emphasis>
    <emphasis># end in vowels? </emphasis>
    &prompt;<command> freq_dist = FreqDist()</command>
    &prompt;<command> for token in tokens:</command>
    &prompt2;<command>     if token.type()[-1].lower() in VOWELS:</command>
    &prompt2;<command>         freq_dist.inc(len(token.type()))</command>

    <emphasis># Plot the results </emphasis>
    &prompt;<command> wordlens = freq_dist.samples() </command>
    &prompt;<command> wordlens.sort()</command>
    &prompt;<command> points = [(l, freq_dist.freq(l)) for l in wordlens]</command>
    &prompt;<command> Plot(points)</command>
</programlisting>
      </section> <!-- Question 2 -->

      <section id="FreqDist.example.question3">
        <title> Words following words ending in vowels </title>

        <para> For the third distribution, we only care about word
        lengths for words following words that end in vowels.  We can
        use a boolean variable, <literal>ended_in_vowel</literal>, to
        keep track of this condition.  Initially, its value is zero;
        and after we examine each token, we update its value for use
        with the next token. </para>

<programlisting>
    <emphasis># What is the distribution of word lengths for words following</emphasis>
    <emphasis># words that end in vowels? </emphasis>
    &prompt;<command> ended_in_vowel = 0</command> <emphasis># Did the last word end in a vowel?</emphasis>
    &prompt;<command> freq_dist = FreqDist()</command>
    &prompt;<command> for token in tokens:</command>
    &prompt2;<command>     if ended_in_vowel: </command>
    &prompt2;<command>         freq_dist.inc(len(token.type()))</command>
    &prompt2;<command>     ended_in_vowel = token.type()[-1].lower() in VOWELS </command>

    <emphasis># Plot the results </emphasis>
    &prompt;<command> wordlens = freq_dist.samples() </command>
    &prompt;<command> wordlens.sort()</command>
    &prompt;<command> points = [(l, freq_dist.freq(l)) for l in wordlens]</command>
    &prompt;<command> Plot(points)</command>
</programlisting>

      </section> <!-- Question 3 -->
    </section> <!-- FreqDist Example -->
  </section> <!-- Frequency Distributions -->

  <section id="ConditionalFreqDist"> 
    <title> Conditional Frequency Distributions </title>
    
    <indexterm><primary>condition</primary></indexterm> 
    <para> A <glossterm>condition</glossterm> specifies the context in
    which an experiment is performed.  Often, we are interested in the
    effect that conditions have on the outcome for an experiment.  For
    example, we might want to examine how the distribution of a word's
    length (the outcome) is affected by the word's initial letter (the
    condition).  Conditional frequency distributions provide a tool
    for exploring this type of question. </para>

    <indexterm><primary>conditional frequency distribution</primary></indexterm>
    <para> A <glossterm>conditional frequency distribution</glossterm>
    is a collection of frequency distributions for the same
    experiment, run under different conditions.  The individual
    frequency distributions are indexed by the condition.  Conditional
    frequency distributions are represented using the <ulink
    url="&refdoc;/nltk.probability.ConditionalFreqDist.html"
    ><literal>ConditionalFreqDist</literal></ulink> class, which is
    defined by the
    <ulink url="&refdoc;/nltk.probability.html"
    ><literal>nltk.probability</literal> module</ulink>. </para>

    <para> The <ulink
    url="&refdoc;/nltk.probability.ConditionalFreqDist.html#__init__"
    ><literal>ConditionalFreqDist</literal> constructor</ulink> creates
    a new empty conditional frequency distribution: </para>

<programlisting>
    &prompt;<command> cfdist = ConditionalFreqDist() </command>
    &lt;ConditionalFreqDist with 0 conditions&gt;
</programlisting>

    <para> To access the frequency distribution for a condition, use
    the <ulink
    url="&refdoc;/nltk.probability.ConditionalFreqDist.html#__getitem__">indexing
    operator</ulink>: </para>

<programlisting>
    &prompt;<command> cfdist['a']</command>
    &lt;FreqDist with 0 outcomes&gt;

    <emphasis># Record the word lengths of some words starting with 'a'</emphasis>
    &prompt;<command> for word in 'apple and arm'.split():</command>
    &prompt2;<command>     cfdist['a'].inc(len(word))</command>

    <emphasis># Of words starting with 'a', how many are 3 characters long?</emphasis>
    &prompt;<command> cfdist['a'].freq(3)</command>
    0.66667
</programlisting>

    <para> There is no need to explicitly specify the set of
    conditions used by a conditional frequency distribution.  Whenever
    you use the indexing operator to access the frequency distribution
    for a new condition, <literal>ConditionalFreqDist</literal>
    automatically creates a new empty <literal>FreqDist</literal> for
    it.  To list the conditions which have been accessed for a
    conditional frequency distribution, use the <ulink
    url="&refdoc;/nltk.probability.ConditionalFreqDist.html#conditions"
    ><literal>conditions</literal></ulink> method: </para>

<programlisting>
    &prompt;<command> cfdist.conditions()</command>
    ['a']
</programlisting>

    <section id="ConditionalFreqDist.initial_letter"> 
      <title> Example: Conditioning on a Word's Initial Letter </title>

      <para> In this section, we use a
      <literal>ConditionalFreqDist</literal> to examine how the
      distribution of a word's length is affected by the word's
      initial letter.  To begin, we load a corpus from a text file,
      and create an empty
      <literal>ConditionalFreqDist</literal>:</para>

<programlisting>
    &prompt;<command> corpus = open('corpus.txt').read() </command>
    &prompt;<command> tokens = WSTokenizer().tokenize(corpus) </command>

    &prompt;<command> cfdist = ConditionalFreqDist()</command>
</programlisting>

      <para> We then examine each token in the corpus, and determine
      its initial letter (the condition) and its word length (the
      outcome).  We use the indexing operator to access the frequency
      distribution for the condition, and use the
      <literal>inc()</literal> method to increment its count for the
      outcome. </para>

<programlisting>
    <emphasis># How does initial letter affect word length?</emphasis>
    &prompt;<command> for token in tokens:</command>
    &prompt2;<command>     outcome = len(token.type())</command>
    &prompt2;<command>     condition = token.type()[0].lower()</command>
    &prompt2;<command>     cfdist[condition].inc(outcome)</command>
</programlisting>

      <para> We can construct a plot to show the frequency of various
      word lengths (outcomes) for a given intial letter (condition):
      </para>

<programlisting>
    <emphasis># Plot the distribution of word lengths for words starting with 'a'</emphasis>
    &prompt;<command> wordlens = cfdist['a'].samples() </command>
    &prompt;<command> wordlens.sort()</command>
    &prompt;<command> points = [(l, cfdist['a'].freq(l)) for l in wordlens]</command>
    &prompt;<command> Plot(points)</command>
</programlisting>

      <para> We can also construct a plot to show how the frequency of
      a word length (outcome) depends on the initial letter
      (condition): </para>

<programlisting>
    <emphasis># Plot the frequency of 3-letter-words for each initial letter. </emphasis>
    &prompt;<command> conditions = cfdist.conditions() </command>
    &prompt;<command> conditions.sort() </command>
    &prompt;<command> points = [(ord(c), cfdist[c].freq(3)) for c in conditions] </command>
    &prompt;<command> Plot(points)</command>
</programlisting>

      <!-- This doesn't add much...
      <note> <para> As mentioned in the previous section, we are
      currently using a fairly simple class to plot functions.  In the
      future, we plan to add bar chart (which would be more
      appropriate for plotting the frequency of 3-letter-words for
      each initial letter); and 3d plots (which could be used to
      simultaneously see the effect of the condition and outcome on
      frequency). </para> </note> 
      -->

    </section> <!-- Example -->

    <section id="ConditionalFreqDist.predict"> 
      <title> Prediction </title>

      <indexterm><primary>Prediction</primary></indexterm>
      <para> Conditional frequency distributions are often used for
      prediction.  <glossterm>Prediction</glossterm> is the problem of
      deciding a likely outcome for a given run of an experiment.  The
      decision of which outcome to predict is usually based on the
      context in which the experiment is performed.  For example, we
      might try to predict a word's type (outcome), based on the type
      of the word that it follows (context). </para>

      <indexterm><primary>training corpus</primary></indexterm>
      <para> To predict the outcomes of an experiment, we first
      examine a representative <glossterm>training corpus</glossterm>,
      where the context and outcome for each run of the experiment are
      known.  When presented with a new run of the experiment, we
      simply choose the outcome that occured most frequently for the
      experiment's context. </para>

      <para> We can use a <literal>ConditionalFreqDist</literal> to
      find the most frequent occurance for each context.  First, we
      record each outcome in the training corpus, using the context
      that the experiment was under as the condition.  Then, we can
      access the frequency distribution for a given context with the
      indexing operator, and use the <literal>max()</literal> method
      to find the most likely outcome. </para>

      <section id="ConditionalFreqDist.predict.example">
        <title> Example: Predicting Words </title>

        <para> In this section, we use a
        <literal>ConditionalFreqDist</literal> to predict a word's
        type, based on the type of the word that it follows.  To
        begin, we load a corpus from a text file, and create an empty
        <literal>ConditionalFreqDist</literal>:</para>

<programlisting>
    &prompt;<command> corpus = open('corpus.txt').read() </command>
    &prompt;<command> tokens = WSTokenizer().tokenize(corpus) </command>

    &prompt;<command> cfdist = ConditionalFreqDist()</command>
</programlisting>

        <para> We then examine each token in the corpus, and increment
        the appropriate sample's count.  We use the variable
        <literal>context</literal> to record the type of the
        preceeding word.  </para>

<programlisting>
    &prompt;<command> context = None </command> <emphasis># The type of the preceeding word</emphasis>
    &prompt;<command> for token in tokens:</command>
    &prompt2;<command>     outcome = token.type()</command>
    &prompt2;<command>     cfdist[context].inc(outcome)</command>
    &prompt2;<command>     context = token.type()</command>
</programlisting>

        <note> 
          <para> Sometimes the context for an experiment is
          unavailable, or does not exist.  For example, the first
          token in a text does not follow any word.  In these cases,
          we must decide what context to use.  For this example, we
          use <literal>None</literal> as the context for the first
          token.  Another option would be to simply discard the first
          token. </para>
        </note>

        <para> Once we have constructed a conditional frequency
        distribution for the training corpus, we can use it to find
        the most likely word for any given context: </para>

<programlisting>
    &prompt;<command> cfdist['prediction'].max() </command>
    'problems'
    &prompt;<command> cfdist['problems'].max() </command>
    'in'
    &prompt;<command> cfdist['in'].max() </command>
    'the'
</programlisting>

        <para> We can set up a simple loop to generate text, by using
        the most likely token for each word as the context for the
        next word: </para>

<programlisting>
    &prompt;<command> word = 'prediction' </command>
    &prompt;<command> for i in range(15): </command>
    &prompt2;<command>     print word, </command>
    &prompt2;<command>     word = cfdist[word].max()</command>
    prediction problems in the frequency distribution of the 
    frequency distribution of the frequency distribution of
</programlisting>

        <note> <para> This simple approach to text generation tends to
        get stuck in loops, as demonstrated by the text generated
        above.  A more advanced approach would be to randomly choose
        each word, with more frequent words chosen more often. </para>
        </note>

      </section> <!-- Example -->

    </section> <!-- Predicting -->

  </section> <!-- ConditionalFreqDist -->

  <section id="ProbDist"> 
    <title> Probability Distributions </title>

    <para> This section is under construction.  For information about
    probability distributions, see the reference documentation for the
    <ulink url="&refdoc;nltk.probability.ProbDistI.html"
    ><literal>ProbDistI</literal> interface</ulink>.  The reference
    documentation includes pointers to all of the classes that
    currently implement the <literal>ProbDistI</literal> interface.
    Also, see the reference documentation for <ulink
    url="&refdoc;nltk.probability.ConditionalProbDist.html"
    ><literal>ConditionalProbDist</literal></ulink>, which is used to
    encode conditional probability distributions. </para>

  </section> <!-- Probability Distributions -->

<!-- ==================================================
     We're not using events any more; but keep this 
     around, in case we bring them back in some form.
     ==================================================
  <section> <title>Events</title>

    <para> An event is a set of samples.  For example, the set of all
    even die outcomes is an event.  Events are written using standard
    set notation: 

<programlisting>
    {Event 1, 2, 3, 6}        <emphasis>The event containing samples 1, 2, 3, and 6</emphasis>
    {Event x: x&lt;3}            <emphasis>The event containing all samples that are less than 3</emphasis>
    {Event x: x is even}      <emphasis>The event containing all even samples</emphasis>
</programlisting>

    Events usually contain more than one sample; but sometimes they
    will contain ony one sample, or will contain no samples at all.
    </para>

    <section> <title> Simple Events </title>
    
      <para> The <literal>nltk.probability</literal> module defines a
      collection of <literal>Event</literal> classes for representing
      events in different ways.  Events are used throughout the
      <literal>probability</literal> module to define and maniuplate
      probability distributions.  The simplest types of event are
      <literal>SampleEvent</literal>s, which just consist of a single
      sample:

<programlisting>
    &prompt;<command> SampleEvent(3)</command>
    {Event 3}
    &prompt;<command> SampleEvent('dog')</command>
    {Event 'dog'}
</programlisting>
      </para>
      
      <para> Events can also be defined in terms of
      <literal>Set</literal>s, using the <literal>SetEvent</literal>
      class:

<programlisting>
    &prompt;<command> SetEvent( Set(1, 3, 5) )</command>
    {Event 3, 1, 5}
    &prompt;<command> SetEvent( Set(1, 12) | Set(5, 7) )</command>
    {Event 5, 1, 12, 7}
</programlisting>
      </para>
      
      <para> <literal>NullEvent</literal> is used to represent the
      event containing no samples; and
      <literal>UniversalEvent</literal> is used to represent the event
      containing all samples:

<programlisting>
    &prompt;<command> NullEvent()</command>
    {Event}
    &prompt;<command> UniversalEvent()</command>
    {Event x}
</programlisting>

      The <literal>UniversalEvent</literal> is different from all the
      other types of events we have seen, since it can contain an
      infinite set of samples.  For example, for an experiment that
      can generate any integer as an outcome,
      <literal>UniversalEvent</literal> contains the set of all
      integers. </para>

    </section>

    <section> <title> Using Events</title>

      <para> To test whether an event contains a sample, use the
      <literal>contains</literal> method:

<programlisting>
    &prompt;<command> event = SetEvent(Set(1, 4, 5, 7))</command>
    &prompt;<command> event.contains(5)</command>
    1
    &prompt;<command> event.contains(9)</command>
    0
</programlisting>
      </para>

      <para> Events can be compared using the <literal>==</literal>
      operator, the <literal>!=</literal> operator, the
      <literal>subset</literal> method, and the
      <literal>superset</literal> method:

<programlisting>
    &prompt;<command> event1 = SetEvent(Set(1, 4, 5, 7))</command>
    &prompt;<command> event2 = SetEvent(Set(1, 7))</command>
    &prompt;<command> event3 = SetEvent(Set(12, 3, 5, 2))</command>
    &prompt;<command> event1 == event2</command>               <emphasis>Is event1 equal to event2?</emphasis>
    0
    &prompt;<command> event1 != event2</command>               <emphasis>Is event1 not equal to event2?</emphasis>
    1
    &prompt;<command> event1.superset(event2)</command>        <emphasis>Is event1 a superset of event2?</emphasis>
    1
    &prompt;<command> event2.subset(event1)</command>          <emphasis>Is event2 a subset of event1?</emphasis>
    1
    &prompt;<command> event3.superset(event2)</command>        <emphasis>Is event3 a superset of event2?</emphasis>
    0
    &prompt;<command> event2.subset(event3)</command>          <emphasis>Is event2 a subset of event3?</emphasis>
    0
</programlisting>
      </para>

      <para> Events can be combined using the
      <literal>union</literal>, <literal>intersection</literal>, and
      <literal>difference</literal> methods:

<programlisting>
    &prompt;<command> event1 = SetEvent(Set(1, 4, 5, 7))</command>
    &prompt;<command> event2 = SetEvent(Set(1, 2, 7))</command>
    &prompt;<command> event1.union(event2)</command>
    {Event 1, 2, 4, 5, 7}
    &prompt;<command> event1.intersection(event2)</command>
    {Event 1, 2, 7}
    &prompt;<command> event1.difference(event2)</command>
    {Event 4, 5}
</programlisting>
      </para>

      <para> To retrieve the set of samples that compose an event, use
      the <literal>samples</literal> method; and to retrieve the
      number of samples contained in an event, use the
      <literal>len</literal> method:

<programlisting>
    &prompt;<command> event = SetEvent(Set(1, 4, 5, 7))</command>
    &prompt;<command> event.samples()</command>
    {1, 4, 5, 7}
    &prompt;<command> event.len()</command>
    4
</programlisting>
      </para>

      <para> Many of these member functions can also be accessed via an operator:

        <informaltable colsep="5">
          <tgroup cols="2">
            <thead><row><entry>Method</entry><entry>Corresponding operator</entry></row>
            </thead>
            <tbody>
              <row>
                <entry><literal><replaceable>event</replaceable>.contains(
                       <replaceable>sample</replaceable> )</literal></entry>
                <entry><literal><replaceable>sample</replaceable> in 
                       <replaceable>event</replaceable></literal></entry>
              </row>
              <row>
                <entry><literal><replaceable>event1</replaceable>.subset(
                       <replaceable>event2</replaceable> )</literal></entry>
                <entry><literal><replaceable>event1</replaceable> &lt;= 
                       <replaceable>event2</replaceable></literal></entry>
              </row>
              <row>
                <entry><literal><replaceable>event1</replaceable>.superset(
                       <replaceable>event2</replaceable> )</literal></entry>
                <entry><literal><replaceable>event1</replaceable> &gt;= 
                       <replaceable>event2</replaceable></literal></entry>
              </row>
              <row>
                <entry><literal><replaceable>event1</replaceable>.union(
                       <replaceable>event2</replaceable> )</literal></entry>
                <entry><literal><replaceable>event1</replaceable> | 
                       <replaceable>event2</replaceable></literal></entry>
              </row>
              <row>
                <entry><literal><replaceable>event1</replaceable>.intersection(
                       <replaceable>event2</replaceable> )</literal></entry>
                <entry><literal><replaceable>event1</replaceable> ^ 
                       <replaceable>event2</replaceable></literal></entry>
              </row>
              <row>
                <entry><literal><replaceable>event1</replaceable>.difference(
                       <replaceable>event2</replaceable> )</literal></entry>
                <entry><literal><replaceable>event1</replaceable> - 
                       <replaceable>event2</replaceable></literal></entry>
              </row>
              <row>
                <entry><literal><replaceable>event1</replaceable>.len()</literal></entry>
                <entry><literal>len(<replaceable>event1</replaceable>)</literal></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </para>

      <para> Sometimes it is impossible to perform one of these
      operations on some types of events.  For example, an event
      containing an infinite number of samples could not possibly
      implement the <literal>samples</literal> method.  Therefore,
      most of the operations described above are optional; if they are
      not implemented for a given type of event, then using them will
      generate a <literal>NotImplementedError</literal> exception. </para>

      <para> In particular, only the <literal>contains</literal>
      method and the <literal>in</literal> operator are guaranteed to
      work on any event.  However, all of the <literal>Event</literal>
      classes in the toolkit implement all of the optional methods,
      with the following exceptions:

        <informaltable colsep="5">
          <tgroup cols="2">
            <thead><row><entry>Event Type</entry><entry>Methods Not Implemented</entry></row>
            </thead>
            <tbody>
              <row>
                <entry><literal>PredEvent</literal></entry>
                <entry><literal>==</literal> operator, <literal>!=</literal> operator, 
                       <literal>subset</literal>, <literal>superset</literal>, 
                       <literal>samples</literal>, <literal>len</literal> operator</entry>
              </row>
              <row>
                <entry><literal>UniversalEvent</literal></entry>
                <entry><literal>==</literal> operator, <literal>!=</literal> operator, 
                       <literal>samples</literal></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </para>
      
    <para> See the reference documentation for  <ulink
    url="http://nltk.sourceforge.net/ref/nltk.probability.EventI.html"
    ><literal>EventI</literal></ulink> for more information on how to use
    events.</para>

    </section>

    <section> <title> Predicated Events</title>
      
      <para> Predicated events are events defined in terms of a
      <glossterm>predicate</glossterm>, or a function that tests
      whether a sample is contained in the event.  Examples of
      predicated events are:

<programlisting>
    {Event x: x&gt;8}            <emphasis>The event containing all samples </emphasis>
                                  <emphasis>that are greater than 8</emphasis>
    {Event x: x is odd}       <emphasis>The event containing all odd samples</emphasis>
</programlisting>

      The first event's predicate tests whether a sample is greater
      than <replaceable>x</replaceable>.  The second event's predicate
      tests whether <replaceable>x</replaceable> is odd.  In both
      cases, the events contains all samples that make their predicate
      true. </para>

      <para> Predicated events are constructed using the
      <literal>PredEvent</literal> class.  The
      <literal>PredEvent</literal> constructor expects a single
      predicate function, which will return <literal>true</literal>
      for all samples contained in the new event.

<programlisting>
    &prompt;<command> def gt8(x): return x&gt;8</command>        <emphasis>Define an function to test</emphasis>
                                      <emphasis>if a sample is greater than 8</emphasis>
    &prompt;<command> def odd(x): return x%2 == 1</command>   <emphasis>Define an "odd" function</emphasis>
    &prompt;<command> oddEvent = PredEvent(odd)</command>
    {Event x: odd(x)}
    &prompt; <command>233 in oddEvent</command>
    1
    &prompt; <command>104 in oddEvent</command>
    0
    &prompt;<command> gt8Event = PredEvent(gt8)</command>
    {Event x: gt8(x)}
    &prompt;<command> 10 in gt8Event</command>
    1
    &prompt;<command> 5 in gt8Event</command>
    0
</programlisting>
      </para>

      <para> Predicated events can also be constructed directly from
      expressions using "lambda" functions (also known as "anonymous"
      functions):

<programlisting>
    &prompt;<command> gt8Event = PredEvent(lambda x: x>8)</command>
    {Event x: &lt;lambda&gt;(x)}
    &prompt;<command> 10 in gt8Event</command>
    1
    &prompt;<command> 5 in gt8Event</command>
    0
</programlisting>
      </para>

    </section>
    
  </section>
  =================================================== -->

  &index;
</article>
