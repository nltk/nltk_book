<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1//EN" [

<!-- Base URL for the reference & tutorial documentation -->
<!ENTITY refdoc "http://nltk.sourceforge.net/ref">
<!ENTITY tutdoc "http://nltk.sourceforge.net/tutorial">

<!-- Index -->
<!ENTITY index SYSTEM "index.xml">

<!-- Prompts for Python code samples -->
<!ENTITY prompt "<prompt>&gt;</prompt><prompt>&gt;</prompt><prompt>&gt;</prompt>">
<!ENTITY prompt2 "<prompt>...</prompt>">
]>

<article>
  <articleinfo>
    <author><firstname>Steven</firstname><surname>Bird</surname></author>
    <authorinitials>sb</authorinitials>
    <title>NLTK Tutorial: Regular Expressions</title>
  </articleinfo>

  <section id="intro"> 
    <title> Introduction </title>

    <note><para> This tutorial provides a gentle introduction to
    regular expressions illustrated with examples from language
    processing.  For a more concise introduction please see the
    Python documentation
    <ulink url="http://www.python.org/doc/current/lib/module-re.html">
    re -- Regular expression operations</ulink>.
    </para></note>

    <para> When written language is stored in a machine it is normally
    represented as a sequence (or <glossterm>string</glossterm>) of
    characters.  Individual words are strings.  A list of words is a
    string.  Entire texts are also strings, including special
    characters for space and newline.  Strings are sometimes
    formatted, such as a "date string" like
    <literal>2002-06-23</literal>.  Whole texts may be formatted, such
    as an email message with header fields followed by the message
    body.  Texts may contain "markup", such as
    <literal>&lt;abbrev&gt;Phila&lt;/abbrev&gt;</literal>, which
    provides information about the interpretation or presentation of
    some piece of text.  Thus in language processing, strings are
    ubiquitous, and they often contain important structure.
    </para>

    <para> Most language processing is performed above the level of
    characters.  For instance, parsing a sentence is a process that
    operates at the level of complete words.  What kinds of processing
    are performed at the character level?  Perhaps word games are the
    most familiar example of such processing.  In completing a
    crossword we may want to know which 3-letter English words end
    with the letter <literal>c</literal>
    (e.g. "arc").  We might want to know how many
    words can be formed from the letters: <literal>a</literal>,
    <literal>c</literal>, <literal>e</literal>, <literal>o</literal>,
    and <literal>n</literal> (e.g. "ocean").  We may
    want to find out which unique English word contains the substring
    <literal>gnt</literal> (left as an exercise for the reader).  In
    all these examples, we are considering which word - drawn from a
    large set of candidates - matches a given pattern.  There are many
    more serious uses of this so-called <glossterm>pattern
    matching</glossterm>.  We may want to break a text into its
    component words, a process known as
    <glossterm>tokenization</glossterm> (see the <ulink
    url="&tutdoc;/introduction/t1.html">introduction</ulink>).  For
    simple tokenization we want to search for locations in the text
    string containing whitespace (space, tab, or newline) or certain
    punctuation symbols, and break the text strings into word strings
    at these points.  Alternatively, we may want to compute the
    relative frequency of particular letters in the text in order to
    guess the language of the text.  For this we must total up the
    number of matches for each character of interest.
    </para>

    <para> So far we have seen elementary examples of pattern
    matching, the matching of individual characters.  More often we
    are interested in matching <emphasis>sequences</emphasis> of
    characters.  For example, part of the operation of a naive
    spell-checker could be to remove a word-final <literal>s</literal>,
    in case it is a plural, and see if the putative singular form
    exists in the dictionary.  For this we must locate
    <literal>s</literal> and remove it, but only if it precedes a word
    boundary.  This requires matching a pattern consisting of two
    characters.
    </para>

    <para> Beyond this pattern matching on the
    <emphasis>content</emphasis> of a text, we often want to process
    the <emphasis>formatting</emphasis> and
    <emphasis>markup</emphasis> of a text.  We may want to check the
    formatting of a document (e.g. to ensure that every sentence
    begins with a capital letter) or to reformat a document
    (e.g. replacing sequences of space characters with a single
    space).  We may want to find all date strings and extract the
    year.  We may want to extract all words contained inside the
    <literal>&lt;abbrev&gt;&lt;/abbrev&gt;</literal> markup in order
    to construct a list of abbreviations.
    </para>

    <para> Processing the content, format and markup of strings is a
    central task in most kinds of NLP.  The most widespread method for
    string processing uses <glossterm>regular expressions</glossterm>,
    the topic of this tutorial.
    </para>

  </section> <!-- Introduction -->

  <section id="simple"> 
    <title> Simple Regular Expressions </title>

    <para> In this section we will see the building blocks for simple
    regular expressions, along with a selection of linguistic
    examples.
    </para>

    <section id="dot">
      <title>The Wildcard</title>

      <para> The "<literal>.</literal>" symbol matches any character.
      For example, the regular expression <literal>s.ng</literal>
      matches the following English words:
        <literal>sang</literal>,
        <literal>sing</literal>,
        <literal>song</literal>, and
        <literal>sung</literal>.
      </para>

      <para> We can also use this symbol for counting characters.
      For instance <literal>....zy</literal> matches six-letter words
      that end in <literal>zy</literal>.  The pattern
      <literal>....berry</literal> finds words like <literal>cranberry</literal>.
      </para>

      <note><para> Note that the <literal>.</literal> symbol matches
      <emphasis>exactly</emphasis> one character, and must be repeated
      for as many characters as should be matched.  To match a
      variable number of characters we must use notation for
      <emphasis>optionality</emphasis>. </para></note>

    </section>

    <section id="qmk">
      <title>Optionality</title>

      <para> The "<literal>?</literal>" symbol indicates that the
      immediately preceding expression is optional.  The expression
      <literal>colou?r</literal> matches both British and American
      spellings, <literal>colour</literal> and
      <literal>color</literal>.  The expression that precedes the
      <literal>?</literal> may be punctuation, such as an optional
      hyphen.  For instance <literal>e-?mail</literal> matches both
      <literal>e-mail</literal> and <literal>email</literal>.
      </para>

    </section>

    <section id="plus">
      <title>Repeatability</title>

      <para> The "<literal>+</literal>" symbol indicates that the
      immediately preceding expression is repeatable, up to an
      arbitrary number of times.  For example, the expression
      <literal>coo+l</literal> matches <literal>cool</literal>,
      <literal>coool</literal>, and so on.  This symbol is
      particularly effective when combined with the
      <literal>.</literal> symbol.  For example,
      <literal>f.+f</literal> matches all words that begin and end
      with the letter <literal>f</literal>
      (e.g. "foolproof").  The expression
      <literal>.+ed</literal> finds words that potentially have the
      past-tense <literal>-ed</literal> suffix.
      </para>

      <para> The "<literal>*</literal>" symbol indicates that the
      immediately preceding expression is both optional and repeatable.
      For example <literal>.*gnt.*</literal> matches all words that
      contain <literal>gnt</literal>.
      </para>

    </section>

    <section id="choices">
      <title>Choices</title>

      <para> Patterns using the wildcard symbol are very effective,
      but there are many instances where we want to limit the set of
      characters that the wildcard can match.  In such cases we can
      use the <literal>[]</literal> notation.  For example, we can
      match only the vowels using <literal>[aeiou]</literal>.  The
      expression <literal>p[aeiou]t</literal> matches the words:
        <literal>pat</literal>,
        <literal>pet</literal>,
        <literal>pit</literal>,
        <literal>pot</literal>, and
        <literal>put</literal>.
      </para>

      <para> We can combine the <literal>[]</literal> notation with
      our notation for repeatability.  For example, expression
      <literal>p[aeiou]+t</literal> matches the words listed above,
      along with: <literal>peat</literal>, <literal>poet</literal>,
      and <literal>pout</literal>.
      </para>

      <note><para> Note that the order of vowels in the regular
      expression is insignificant, and we would have had the same
      result with the expression <literal>p[uoiea]+t</literal>.  Thus,
      inside these brackets, the characters are interpreted not as a
      string but as a set of choices.
      </para></note>

      <para> Often the choices we want to describe cannot be expressed
      at the level of individual characters.  For example, if we were
      processing the output of a tagger to extract noun phrases, we
      might want to find all nouns (<literal>NN.*</literal>), adjectives
      (<literal>JJ.*</literal>), determiners (<literal>DT</literal>) and
      cardinals (<literal>CD</literal>), while excluding all other word
      types (e.g. verbs <literal>VB.*</literal>).  It is possible,
      using a single regular expression, to search for this set of
      candidates using the choice operator <literal>|</literal> as
      follows: <literal>NN.*|JJ.*|DT|CD</literal>.
      </para>

      <para> As another example of multi-character choices, suppose
      that we wanted to create a program to simplify English prose,
      replacing rare words (like <emphasis>habitation</emphasis>) with
      a more frequent, synonymous word (like
      <emphasis>home</emphasis>).  In this situation, we need to map
      from a potentially large set of words to an individual word.  We
      can match the set of words using the choice operator.  In the
      case of the word <emphasis>home</emphasis>, we would want to
      match the regular expression
      <literal>dwelling|domicile|abode|habitation</literal>.
      </para>

      <note><para> Note that the choice operator has wide scope, so that
      <literal>abc|def</literal> is a choice between <literal>abd</literal>
      and <literal>def</literal>, and not between
      <literal>abced</literal> and <literal>abdef</literal>.  The latter
      choice must be written using parentheses: <literal>ab(c|d)ed</literal>.
      </para></note>

    </section>

  </section>

  <section id="intermediate"> <title> More Complex Regular Expressions
  </title>

    <para>In this section we will cover operators which can be used to
    construct more powerful and useful regular expressions.
    </para>

    <section id="ranges"> <title> Ranges </title>

      <para>In section <xref linkend="choices"/> we saw how the
      <literal>[]</literal> notation could be used to express a set of
      choices between individual characters.  Instead of listing each
      character, it is also possible to express a <emphasis>range</emphasis>
      of characters, using the <literal>-</literal> operator.  For example,
      <literal>[a-z]</literal> matches any lowercase letter.
      </para>

      <para>As expected, ranges can be combined with other operators.
      For example <literal>[A-Z][a-z]*</literal> matches words that have
      an initial capital letter followed by any number of lowercase
      letters.  The expression <literal>20[0-4][0-9]</literal> matches
      years in the range 2000 to 2049.
      </para>

      <para>Ranges can be combined, e.g.
      <literal>[a-zA-Z]</literal> which matches any lowercase or uppercase
      letter.  The expression <literal>[b-df-hj-np-tv-z]+</literal> matches
      words consisting only of consonants (e.g. "pygmy").
      </para>

    </section>

    <section id="complementation"> <title> Complementation </title>

      <para>The notation <literal>[^aeiou]</literal> - much simpler
      than <literal>[b-df-hj-np-tv-z]+</literal>...
      Also for ranges <literal>[^a-f]</literal>.
      </para>

    </section>

    <section id="special"> <title> Common Special Symbols </title>

      <para>^, $, \, \n </para>

    </section>

  </section>

  <section id="advanced"> 
    <title> Advanced Regular Expressions </title>

    <para>greedy vs non-greedy matching</para>

    <para>zero-width assertions</para>

    <para>more special symbols: \b etc</para>

  </section>

  <section id="python_interface"> 
    <title> Python Interface </title>

    <para> How to do regexps in Python - give a couple of code samples
    for the above prose illustrations.  Use /usr/dict/words - local copy. </para>

<programlisting>
<emphasis># Load the regular expression module:</emphasis>
&prompt; <command>from re import *</command>
<emphasis># Read a big list of words:</emphasis>
&prompt; <command>words = open('/home/sb/nltk/data/words', 'r').read()</command>
<emphasis># How many words are there?</emphasis>
&prompt; <command>len(words)</command>
409093
<emphasis># Compile a regexp for 3-letter words ending in c</emphasis>
&prompt; <command>r = compile(r'^..c$', MULTILINE)</command>
<emphasis># Find all matches</emphasis>
&prompt; <command>print r.findall(words)</command>
['arc', 'Doc', 'Lac', 'Mac', 'Vic']
</programlisting>

  </section>

</article>
