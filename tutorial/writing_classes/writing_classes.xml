<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1//EN" [
<!ENTITY prompt "<prompt>&gt;</prompt><prompt>&gt;</prompt><prompt>&gt;</prompt>">
<!ENTITY prompt2 "<prompt>...</prompt>">
]>

<article>
  <articleinfo>
    <author><firstname>Edward</firstname><surname>Loper</surname></author>
    <authorinitials>edl</authorinitials>
    <title>NLTK Tutorial: Writing Classes for NLTK</title>
  </articleinfo>

  <section> <title> Introduction </title>

    <para> This tutorial is intended to help you write your own
    classes for use with the toolkit.  We assume that you understand
    the basic concepts of object-oriented programming.  If not, we
    recommend that you read chapter six of <citetitle>Learning
    Python</citetitle> (<author><surname>Lutz</surname></author> &amp;
    <author><surname>Ascher</surname></author>). </para>

    <para> You will generally be interested in writing two different
    types of classes: <glossterm>data classes</glossterm>; and
    <glossterm>processing</glossterm> (or
    <glossterm>task-oriented</glossterm>) classes. 
    Data classes are used to store information that is relavant to
    some task.  Examples of data classes are <ulink
    url="http://nltk.sourceforge.net/ref/nltk.token.Location.html"
    ><literal>Location</literal></ulink>, <ulink
    url="http://nltk.sourceforge.net/ref/nltk.token.Token.html"
    ><literal>Token</literal></ulink>, and <ulink
    url="http://nltk.sourceforge.net/ref/nltk.probability.SimpleFreqDist.html"
    ><literal>SimpleFreqDist</literal></ulink>.  Processing classes
    define methods that can be used to perform a variety of tasks.
    Examples of processing classes are <ulink
    url="http://nltk.sourceforge.net/ref/nltk.token.WSTokenizer.html"
    ><literal>WSTokenizer</literal></ulink>, <ulink
    url="http://nltk.sourceforge.net/ref/nltk.tagger.UnigramTagger.html"
    ><literal>UnigramTagger</literal></ulink>, and <ulink
    url="http://nltk.sourceforge.net/ref/nltk.chartparser.ChartParser.html"
    ><literal>ChartParser</literal></ulink>. </para>

  </section>

  <section> <title> Writing Classes in Python </title>

    <para> This section gives a very brief description of Python's
    class system.  If you are already comfortable with writing classes
    in Python, you can safely skip this section.  For more in-depth
    information on how to use object-oriented programming with Python,
    please refer to a Python textbook, such as <citetitle>Learning
    Python</citetitle> (<author><surname>Lutz</surname></author> &amp;
    <author><surname>Ascher</surname></author>). </para>

    <section> <title> Declaring Classes </title>

      <para> Python classes are declared with the
      <literal>class</literal> keyword.  This keyword begins a block,
      which should contain method definitions.  Method definitions
      have the same form as function definitions.  </para>

<programlisting>
    &prompt;<command> class SimpleClass:</command>
    &prompt2;<command>     def set(self, value):</command>
    &prompt2;<command>         self.data = value</command>
    &prompt2;<command>     def get(self):</command>
    &prompt2;<command>         print self.data</command>
</programlisting>

    </section>
    <section> <title> Explicit Qualification </title>

      <para> Unlike methods in most object oriented languages, Python
      methods all take the object being acted on as an explicit
      argument.  This argument is conventionally called
      <literal>self</literal>, and is the first argument to any
      method.  Any member variables must be accessed through
      <literal>self</literal>.  In the above example, the
      <literal>data</literal> member variable is accessed as
      <literal>self.data</literal>.  </para>

      <para> This <glossterm>explicit qualification</glossterm> of
      member variables may seem annoying to programmers who are used
      to the more conventional <glossterm>implicit
      qualification</glossterm>.  However, it allows you to clearly
      distinguish member variables from local variables.  In fact,
      making this distinction clear is one of the reasons that many
      programmers prefer to begin member variables with a prefix (such
      as "<literal>m_</literal>"). </para>

    </section>
    <section><title> Constructors </title>

      <para> New member variables are created simply by assigning to
      them.  It is an error to read from a member variable before it
      has been assigned to.  To ensure that all member variables are
      properly initialized, most classes define a
      <glossterm>constructor</glossterm>.  A class's constructor is
      called whenever a new instance is created.  Like all member
      functions, it recieves the object being acted on as an explicit
      argument.  The class constructor is named
      <literal>__init__</literal>, to distinguish it from other
      methods. </para>

<programlisting>
    &prompt;<command> class SimpleClass:</command>
    &prompt2;<command>     def __init__(self):</command>
    &prompt2;<command>         self.data = 0</command>
    &prompt2;<command>     def set(self, value):</command>
    &prompt2;<command>         self.data = value</command>
    &prompt2;<command>     def get(self):</command>
    &prompt2;<command>         print self.data</command>
    &prompt2;
    &prompt;<command> x = SimpleClass()</command>
</programlisting>

      <para> If the constructor takes additional arguments, then those
      arguments must be given when creating a new instance: </para>

<programlisting>
    &prompt;<command> class SimpleClass:</command>
    &prompt2;<command>     def __init__(self, initial_value):</command>
    &prompt2;<command>         self.data = initial_value</command>
    &prompt2;<command>     def set(self, value):</command>
    &prompt2;<command>         self.data = value</command>
    &prompt2;<command>     def get(self):</command>
    &prompt2;<command>         print self.data</command>
    &prompt2;
    &prompt;<command> x = SimpleClass(4)</command>
</programlisting>

    </section>
    <section> <title> Inheritance </title>

      <para> You can specify that a new class <literal>B</literal> is
      a subclass of <literal>A</literal> with the following syntax:
      </para>

<programlisting>
    &prompt;<command> class B(A):</command>
    &prompt2;<command>     def __init__(self):</command>
                 .
                 .
</programlisting>

      <para> You should also use this syntax to specify that a new
      class <literal>B</literal> implements the interface
      <literal>A</literal>. </para>

    </section>

  </section> <!-- Writing classes in python -->

  <section> <title> Processing Classes </title>

    <para> Processing classes define one or more methods that can be
    used to process data.  Each processing class typically implements
    some interface, which specifies the behavior for its processing
    methods.  For example, <ulink
    url="http://nltk.sourceforge.net/ref/nltk.token.WSTokenizer.html"
    ><literal>WSTokenizer</literal></ulink> is a processing class that
    implements the <ulink
    url="http://nltk.sourceforge.net/ref/nltk.token.TokenizerI.html"
    ><literal>TokenizerI</literal></ulink> interface. </para>

    <para> NLTK uses class inheritence to indicate that a class
    implements an interface.  For example, the following code defines
    a new class implementing the <literal>TokenizerI</literal>
    interface: </para>

<programlisting>
    &prompt;<command> class SimpleTokenizer(TokenizerI):</command>
    &prompt2;<command>     def tokenize(self, str): </command>
    &prompt2;<command>         words = str.split()</command>
    &prompt2;<command>         return [Token(words[i], i) </command>
    &prompt2;<command>                 for i in range(len(words))]</command>
</programlisting>

    <para> Whenever you define a new processing class that implements
    an interface, you must provide definitions for every method
    defined by the interface. </para>

    <section> <title> Customization Parameters </title>

      <para> Some processing classes have <emphasis>customization
      parameters</emphasis>.  These are values given to the
      constructor, which determine how the class will process its
      input.  For example, the <ulink
      url="http://nltk.sourceforge.net/ref/nltk.token.RETokenizer.html"
      ><literal>RETokenizer</literal></ulink> class takes a single
      customization parameter: a regular expression, which it uses to
      determine how it should tokenize texts. </para>

    </section>
    <section> <title> State </title>

      <para> Processing classes can be either
      <glossterm>stateful</glossterm> or
      <glossterm>stateless</glossterm>.  A
      <glossterm>stateful</glossterm> processing class maintains
      dynamic information in its member variables, and uses this
      information while processing input.  For example, the <ulink
      url="http://nltk.sourceforge.net/ref/nltk.tagger.UnigramTagger.html"
      ><literal>UnigramTagger</literal></ulink> class maintains an
      internal frequency distribution, which it uses to decide which
      tag to associate with each word type. </para>

    </section>

  </section> <!-- Processing classes -->

  <section> <title> Data Classes </title>

    <note> 
      <para> (under construction) </para>
    </note>

  </section> <!-- Data Classes -->
</article>

