.. -*- mode: rst -*-
.. include:: ../definitions.txt
.. include:: regexp-defns.txt
.. sectnum::

===================================
6. Structured Programming in Python
===================================

------------
Introduction
------------

In this chapter we pick up where we left off in |Programming|.  We
assume you are confident with the material presented there and have
tried lots of exercises in the intervening chapters.  Here we will
consolidate your knowledge of the key programming concepts and explain
many of the minor points that could easily trip you up.  We also
introduce new topics in structured programming and algorithmic problem
solving.  The chapter contains many working program fragments and
exercises which you should try yourself.

------
Review
------

Sequences: Strings, Lists and Tuples
------------------------------------

In Part I we saw three kinds of sequence object: strings, lists, and tuples.
As sequences they have some common properties: they can be indexed and they have
a length:

    >>> string = "I turned off the spectroroute"
    >>> words = ["I", "turned", "off", "the", "spectroroute"]
    >>> pair = (6, "turned")
    >>> string[2], words[3], pair[1]
    "t", "the", "turned"
    >>> len(string), len(words), len(pair)
    29, 5, 2

|nopar|
We can iterate over a sequence ``s`` using the construct ``for item in s``.
We can iterate in sorted order using ``for item in sorted(s)``,
and we can eliminate duplicates using ``for item in set(s)`` or
``for item in sorted(set(s))``.
For convenience, we can convert between these types, e.g.
``tuple(s)`` converts a sequence into a tuple, and
``list(s)`` converts a sequence into a list.
We can convert a list of strings to a single string using the
``join`` function, e.g. ``":".join(words)``.

Notice in the above code sample that we computed multiple values
on a single line, separated by commas.  Lines of comma-separated
expressions are actually just tuples.  We use tuples to spontaneously
aggregate items.  In the next example we use tuples to move items
around inside a list without using temporary variables.

    >>> words[2], words[3], words[4] = words[3], words[4], words[2]
    >>> words    
    ['I', 'turned', 'the', 'spectroroute', 'off']

|nopar|
Here we define a function that returns a tuple consisting of the
average word length of a sentence, and the inventory of letters
used in the sentence.

    >>> def proc_words(words):
    ...     avg_wordlen = sum(len(word) for word in words)/len(words)
    ...     chars_used = ''.join(sorted(set(''.join(words))))
    ...     return avg_wordlen, chars_used
    >>> proc_words(words)
    (5, 'Icdefhnoprstu')

List Comprehensions
-------------------

Many language processing tasks involve applying the same operation to
every item in a list.  `List comprehensions`:dt: are a convenient Python
construct for doing this.  Here we lowercase each word:

    >>> sent = ['The', 'dog', 'gave', 'John', 'the', 'newspaper']
    >>> [word.lower() for word in sent]
    ['the', 'dog', 'gave', 'john', 'the', 'newspaper']

As another example, we could remove all determiners from a list of
words:

    >>> def is_lexical(word):
    ...     return word.lower() not in ('a', 'an', 'the', 'that', 'to')
    >>> [word for word in sent if is_lexical(word)]
    ['dog', 'gave', 'John', 'newspaper']

Or equivalently:

    >>> filter(is_lexical, sent)
    ['dog', 'gave', 'John', 'newspaper']

Combining the transformations...

    >>> [word.lower() for word in sent if is_lexical(word)]
    ['dog', 'gave', 'john', 'newspaper']


The following code builds a list of tuples, where each tuple consists
of a word and its length.

    >>> [(x, len(x)) for x in sent]
    [('The', 3), ('dog', 3), ('gave', 4), ('John', 4), ('the', 3), ('newspaper', 9)]

Putting it Together
-------------------

Let's combine our knowledge of the three sequence types and list
comprehensions to perform the task of sorting the words in a string by
their length.

    >>> words = "I turned off the spectroroute".split()
    >>> wordlens = [(len(word), word) for word in words]
    >>> wordlens.sort()
    >>> " ".join(word for count, word in wordlens)
    "I off the turned spectroroute"

Each of the above lines of code contains a significant feature.
The first line demonstrates that a simple string is actually
an object with methods defined on it, such as ``split()``.
The second line shows the construction of a list of tuples,
where each tuple consists of a number (the word length) and the
word, e.g. ``(3, "the")``.  The third line sorts the list,
modifying the list in-place.  The last line of code discards
the length information then joins the words back into a single string.
    
We began by talking about the commonalities in these sequence types,
but the above program illustrates important differences in their
roles.  First, strings appear at the beginning and the end: this is
typical in the context where our program is reading in some text and
producing output for us to read.  Lists and tuples are used in the
middle, but for different purposes.  A list is typically a sequence of
objects all having the same type, of arbitrary length.  We often
use lists to hold sequences of words.  In contrast,
a tuple is typically a collection of objects of different types, of
fixed length.  We often use a tuple to hold a `record`:dt:,
a collection of different `fields`:dt: relating to some entity.
The distinction is a bit subtle, so here is another example:

    >>> lexicon = [
    ...    ('the', 'DT', ['Di:', 'D@'])
    ...    ('off', 'IN', ['Qf', 'O:f'])
    ... ]

A lexicon is represented as a list as it is a collection of objects
of a single type |mdash| lexical entries |mdash| of no predetermined
length.  An individual entry is represented as a tuple, as it is
a collection of objects with different interpretations, such as
the orthographic form, the part of speech, and the pronunciations
represented in the SAMPA system.
However, these pronunciations are again a list (why?).

This distinction between lists and tuples has been described in terms of
usage.  However, there is a more fundamental difference: in Python,
lists are `mutable`:dt:, while tuples are `immutable`:dt:.  In other
words, lists can be modified, while tuples cannot.  Here are some of
the operations on lists which do in-place modification of the list.
None of these operations is permitted on a tuple:

    >>> lexicon.sort()
    >>> lexicon[1] = ('turned', 'VBD', ['t3:nd', 't3`nd'])
    >>> del lexicon[0]


More List Comprehensions
------------------------

We can build a list of n-grams as follows:

    >>> n = 3
    >>> [sent[i:i+n] for i in range(len(sent)-n+1)]
    [['The', 'dog', 'gave'],
     ['dog', 'gave', 'John'],
     ['gave', 'John', 'the'],
     ['John', 'the', 'newspaper']]

Multiple iteration:

    >>> [(dt,jj,nn) for dt in ("two", "three")
    ...             for jj in ("old", "blind")
    ...             for nn in ("men", "mice")]

Nesting:

    >>> from numpy import average
    >>> average([len(w) for sent in brown.raw('a') for w in sent])
    4.401545438271973

Conditions:

    >>> [word for sent in brown.raw('a') for w in sent if len(word) == 12]

Generator expressions: when a list comprehension occurs as the argument
of a function, we can often leave out the brackets.

Making Copies
-------------

Variables as named locations:

    >>> a = "cat"
    >>> b = a
    >>> b
    "cat"

|nopar|
If we modify ``a``, ``b`` is unchanged:

    >>> a = "dog"
    >>> b
    "cat"

What happens with lists?  

    >>> sent1 = ["the", "cat"]
    >>> sent2 = sent1
    >>> sent2
    ["the", "cat"]

|nopar|
So far so good, that's exactly what we expected.
Now let's modify ``a``:

    >>> sent1[1] = "dog"
    >>> sent1
    ["the", "dog"]
    >>> sent2
    ["the", "dog"]

Why has ``b`` changed, when we didn't touch it?  To understand why, we need to
know how lists are stored in the computer's memory.  [Arrays]

.. _array-memory:
.. figure:: ../images/array-memory.png
   :scale: 20

   Arrays and Computer Memory

|nopar|
Deep copy:

    >>> sent2 = sent1[:]





Formatted Strings
-----------------

Formatted output typically contains a combination of variables and
pre-specified strings, e.g. given a dictionary ``wordcount``
consisting of words and their frequencies we could do:

    >>> wordcount = {'cat':3, 'dog':4, 'snake':1}
    >>> for word in wordcount:
    ...     print word, "->", wordcount[word], ";",
    dog -> 4 ; cat -> 3 ; snake -> 1

Apart from the problem of unwanted whitespace, such print statements
alternating variables and constants can be difficult to read and
maintain.  Instead:

    >>> for word in wordcount:
    ...    print "%s->%d;" % (word, wordcount[word]),
    dog->4; cat->3; snake->1
    
**Tabulation:**

Now that we can load a significant quantity of tagged text, we can
process it and extract items of interest.  The following code iterates
over the fifteen genres of the Brown Corpus (accessed using
``brown.items()``).  Each of these is tokenized in turn.  The next
step is to check if the token has the ``md`` tag.  For each of these
words we increment a count.  This uses the conditional frequency
distribution, where the condition is the current genre, and the event
is the modal.

    >>> cfdist = ConditionalFreqDist()
    >>> for genre in brown.items:                  # each genre
    ...     for sent in brown.tagged(genre):       # each sentence
    ...         for (word,tag) in sent:            # each tagged token
    ...             if tag == 'md':                # found a modal
    ...                  cfdist[genre].inc(word.lower())

The conditional frequency distribution is nothing more than a mapping
from each genre to the distribution of modals in that genre.  The
following code fragment identifies a small set of modals of interest,
and processes the data structure to output the required counts.

    >>> modals = ['can', 'could', 'may', 'might', 'must', 'will']
    >>> print "%-18s" % 'Genre', ' '.join([("%6s" % m) for m in modals])
    Genre                 can  could    may  might   must   will
    >>> for genre in cfdist.conditions():    # generate rows
    ...     print "%-18s" % brown.item_name[genre],
    ...     for modal in modals:
    ...         print "%6d" % cfdist[genre].count(modal),
    ...     print
    press: reportage       94     86     66     36     50    387
    press: reviews         44     40     45     26     18     56
    press: editorial      122     56     74     37     53    225
    skill and hobbies     273     59    130     22     83    259
    religion               84     59     79     12     54     64
    belles-lettres        249    216    213    113    169    222
    popular lore          168    142    165     45     95    163
    miscellaneous: gov    115     37    152     13     99    237
    fiction: general       39    168      8     42     55     50
    learned               366    159    325    126    202    330
    fiction: science       16     49      4     12      8     16
    fiction: mystery       44    145     13     57     31     17
    fiction: adventure     48    154      6     58     27     48
    fiction: romance       79    195     11     51     46     43
    humor                  17     33      8      8      9     13

There are some interesting patterns in this table.  For instance,
compare the rows for government literature and adventure literature;
the former is dominated by the use of ``can, may, must, will`` while
the latter is characterised by the use of ``could`` and ``might``.
With some further work it might be possible to guess the genre of a
new text automatically, according to its distribution of modals.

**Example: concordance display**

Issues: handling padding, escaping ``%`` in formatting strings, alignment

    >>> context = 30
    >>> word = "line"
    >>> format = "%%%ds %s %%-%ds" % (context, word, context)
    >>> for sent in brown.raw('a'):
    ...     try:
    ...         pos = sent.index(word)
    ...         left = ' '.join(sent[:pos])
    ...         right = ' '.join(sent[pos+1:])
    ...         print format % (left[-context:], right[:context])
    ...     except ValueError:
    ...         pass
     , is today closer to the NATO line .                             
    more activity across the state line in Massachusetts than in Rhode
     gained five yards through the line and then uncorked a 56-yard to
                   `` Our interior line and out linebackers played exc
    then moved Cooke across with a line drive to left . Jay Porter dre
    al doubled down the rightfield line and Cooke singled off Phil Sha
    1 -- ( AP ) -- Billy Gardner's line double , which just eluded the
     Jan. 23 -- Nick Skorich , the line coach for the football champio
     general manager . Maris is in line for a big raise .             
    d be impossible to work on the line until then because of the larg
           Murray makes a complete line of ginning equipment except fo
      The company sells a complete line of gin machinery all over the 
    er Co. of Sherman makes a full line of gin machinery and equipment
    ed E. Perlman said Tuesday his line would face the threat of bankr
    ale of property disposed of in line with a plan of liquidation . L
    ittle effort spice up any chow line .                             
     , filed through the cafeteria line .                             
    be particularly sensitive to a line between first and second class
    skilled worker on the assembly line , for example , earns $37 a we


Exercises
---------

#. Find out more about sequence objects using Python's help facility.
   In the interpreter, type ``help(str)``, ``help(list)``, and ``help(tuple)``.
   This will provide a full list of the functions supported by each type.
   Some functions have special names flanked with underscore; as the
   help documentation shows, each such function corresponds to something
   more familiar.  For example ``x.__getitem__(y)`` is just a long-winded
   way of saying ``x[y]``.

#. Write code that removes whitespace at the beginning and end of a
   string, and normalizes whitespace between words to be a single
   space character.

   #) do this task using ``split()`` and ``join()``

   #) do this task using regular expression substitutions


#. Write code that takes a list of words (containing duplicates) and
   returns a list of words (with no duplicates) sorted by decreasing frequency.
   E.g. if the input list contained 10 instances of the word ``table`` and 9 instances
   of the word ``chair``, then ``table`` would appear before ``chair`` in the output
   list.

---------
Functions
---------

* call by reference vs call by name

    >>> def set_up(word, properties):
    ...     word = "cat"
    ...     properties['pos'] = 'noun'
    >>> w = "", p = {}
    >>> set_up(w, p)
    >>> print w
    ""
    >>> print p
    {'pos': 'noun'}

* keyword arguments
* return
* function pointers

    >>> words.sort(cmp)
    ["I", "off", "the", "spectroroute", "turned"]

    >>> words.sort(lambda x, y: cmp(len(y), len(x)))
    ["spectroroute", "turned", "off", "the", "I"]

This is inefficient when the list of items gets long, as
we compute ``len()`` twice for every comparison (about 2nlog(n) times).
The following is more efficient:

    >>> [pair[1] for pair in sorted((len(w), w) for w in words)[::-1]]
    ['spectroroute', 'turned', 'the', 'off', 'I']

This technique is called decorate-sort-undecorate
(also Schwartzian Transform).



Predicting the Next Word (Revisited)
------------------------------------


    >>> from nltk_lite.corpora import genesis
    >>> from nltk_lite.probability import ConditionalFreqDist
    >>> cfdist = ConditionalFreqDist()

We then examine each token in the corpus, and increment the
appropriate sample's count.  We use the variable ``prev`` to record
the previous word.

    >>> prev = None
    >>> for word in genesis.raw():
    ...     cfdist[prev].inc(word)
    ...     prev = word

.. Note:: Sometimes the context for an experiment is unavailable, or
   does not exist.  For example, the first token in a text does not
   follow any word.  In these cases, we must decide what context to
   use.  For this example, we use ``None`` as the context for the
   first token.  Another option would be to discard the first token.

Once we have constructed a conditional frequency distribution for the
training corpus, we can use it to find the most likely word for any
given context. For example, taking the word `living`:lx: as our context,
we can inspect all the words that occurred in that context.

    >>> word = 'living'
    >>> cfdist[word].samples()
    ['creature,', 'substance', 'soul.', 'thing', 'thing,', 'creature']

We can set up a simple loop to generate text: we set an initial
context, picking the most likely token in that context as our next
word, and then using that word as our new context:

    >>> word = 'living'
    >>> for i in range(20):
    ...     print word,
    ...     word = cfdist[word].max()
    living creature that he said, I will not be a wife of the land
    of the land of the land



NOW: doing this with functions...

Recursive Functions
-------------------

Iterative solution:

    >>> def selection(a):
    ...     for i in range(len(a) - 1):
    ...         min = i
    ...         for j in range(i+1, len(a)):
    ...             if a[j] < a[min]:
    ...                 min = j
    ...         a[min],a[i] = a[i],a[min]
    ...     return count


    >>> def factorial(n):
    ...     result = 1
    ...     for i in range(n+1):
    ...         result *= i
    ...     return result

Recursive solution (base case, induction step)

    >>> def factorial(n):
    ...     if n == 1:
    ...         return n
    ...     else:
    ...         return n * factorial(n-1)


Generating all permutations of words, to check which ones are
grammatical:

    >>> def perms(seq):
    ...     if len(seq) <=1:
    ...         return seq
    ...     else:
    ...         permutations = []
    ...         for perm in perms(seq[1:]):
    ...             for i in range(len(perm)+1):
    ...                 permutations.append(perm[:i] + seq[0:1] + perm[i:])
    ...     return permutations
    >>> perms(['police', 'fish', 'cream'])
    [['police', 'fish', 'cream'], ['fish', 'police', 'cream'],
     ['fish', 'cream', 'police'], ['police', 'cream', 'fish'],
     ['cream', 'police', 'fish'], ['cream', 'fish', 'police']]




Functional Decomposition
------------------------

Well-structured programs often make extensive use of functions.  Often
when a block of program code grows longer than a screenful, it is a
great help to readability if it is decomposed into one or more
functions.



-----
Trees
-----

In this part of the book we will be investigating the constituent
structure of sentences, and we will see how these can be represented
using syntactic trees.  Here we will look at tree structures in NLTK.

A tree is a set of connected nodes, each of which is labeled with a
category.  It common to use a 'family' metaphor to talk about the
relationships of nodes in a tree: for example, `S`:gc: is the
`parent`:dt: of `VP`:gc:; conversely `VP`:gc: is a `daughter`:dt: (or
`child`:dt:) of `S`:gc:.  Also, since `NP`:gc: and `VP`:gc: are both
daughters of `S`:gc:, they are also `sisters`:dt:. 
Here is an example of a tree:

.. ex::
  .. tree:: (S (NP Lee) (VP (V saw) (NP the dog)))

Although it is helpful to represent trees in a graphical format, for
computational purposes we usually need a more text-oriented
representation. One standard method is to use a combination of bracket
and labels to indicate the structure, as shown here:

.. doctest-ignore::
      (S 
         (NP  'Lee')
         (VP 
            (V 'saw')
            (NP 
               (Det 'the')
               (N  'dog'))))

The conventions for displaying trees in NLTK are similar:

.. doctest-ignore::
      (S: (NP: 'Lee') (VP: (V: 'saw') (NP: 'the' 'dog')))

In such trees, the node value is a string containing the tree's
constituent type (e.g., `NP`:gc: or `VP`:gc:), while the children encode
the hierarchical contents of the tree [#]_.

.. [#] Although the ``Tree`` class is usually used for encoding
   syntax trees, it can be used to encode *any* homogeneous hierarchical
   structure that spans a text (such as morphological structure or
   discourse structure).  In the general case, leaves and node values do
   not have to be strings.

Trees are created with the ``Tree`` constructor, which takes a
node value and a list of zero or more children.  Here's an example of
a simple NLTK tree with a single child node, where the latter is a token:

    >>> from nltk_lite.parse.tree import Tree
    >>> tree1 = Tree('NP', ['John'])
    >>> print tree1
    (NP: 'John')

Here is an example with two children:

    >>> tree2 = Tree('NP', ['the', 'man'])
    >>> print tree2
    (NP: 'the' 'man')

Finally, here is a more complex example, where one of the
children is itself a tree:

    >>> tree3 = Tree('VP', ['saw', tree2])
    >>> print tree3
    (VP: 'saw' (NP: 'the' 'man'))

A tree's root node value is accessed with the ``node`` property, and
its leaves are accessed with the ``leaves()`` method:

    >>> tree3.node
    'VP'
    >>> tree3.leaves()
    ['saw', 'the', 'man']

One common way of defining the subject of a sentence `S`:gc: in
English is as *the noun phrase that is the daughter of* `S`:gc: *and
the sister of* `VP`:gc:. Although we cannot access subjects directly,
in practice we can get something similar by using `tree
positions`:dt:. Consider ``tree4`` defined as follows:

    >>> tree4 = Tree('S', [tree1, tree3])
    >>> print tree4
    (S: (NP: 'John') (VP: 'saw' (NP: 'the' 'man')))

Now we can just use indexing to access the subtrees of this tree:

    >>> tree4[0]
    (NP: 'John')
    >>> tree4[1]
    (VP: 'saw' (NP: 'the' 'man'))

Since the value of ``tree4[1]`` is itself a tree, we can index into that as well:

    >>> tree4[1][0]
    'saw'
    >>> tree4[1][1]
    (NP: 'the' 'man')

The printed representation for complex trees can be difficult to read.
In these cases, the ``draw`` method can be very useful. 

.. doctest-ignore::
    >>> tree3.draw()

This method opens a new window, containing a graphical representation
of the tree:

.. image:: ../images/parse_draw.png
   :scale: 70

The tree display window allows you to zoom in and out;
to collapse and expand subtrees; and to print the graphical
representation to a postscript file (for inclusion in a document).

To compare multiple trees in a single window, we can use the
``draw_trees()`` method:

.. doctest-ignore::
    >>> from nltk_lite.draw.tree import draw_trees
    >>> draw_trees(tree1, tree2, tree3)

The ``Tree`` class implements a number of other useful methods.  See
the ``Tree`` reference documentation for more information about these
methods.

The ``nltk_lite.corpora`` module defines the ``treebank`` corpus,
which contains a collection of hand-annotated parse trees for English
text, derived from the Penn Treebank.

    >>> from nltk_lite.corpora import treebank, extract
    >>> print extract(0, treebank.parsed())
    (S:
      (NP-SBJ:
        (NP: (NNP: 'Pierre') (NNP: 'Vinken'))
        (,: ',')
        (ADJP: (NP: (CD: '61') (NNS: 'years')) (JJ: 'old'))
        (,: ','))
      (VP:
        (MD: 'will')
        (VP:
          (VB: 'join')
          (NP: (DT: 'the') (NN: 'board'))
          (PP-CLR:
            (IN: 'as')
            (NP: (DT: 'a') (JJ: 'nonexecutive') (NN: 'director')))
          (NP-TMP: (NNP: 'Nov.') (CD: '29'))))
      (.: '.'))


Recursion on Trees
------------------

1. recurse over tree to display in some useful way (e.g. whitespace formatting)

2. recurse over tree to look for coordinate constructions (cf 4th
   example in chapter 1.1)

3. generate new dependency tree from a phrase-structure tree

(possible extension: callback function for Tree.subtrees())


XML and ElementTree
-------------------

* inspecting and processing XML
* example: find nodes matching some criterion and add an attribute


------------
Dictionaries
------------

* persistent storage
* dictionary keys and immutability

-------------------------
Writing Complete Programs
-------------------------

Classifying Words Automatically
-------------------------------

A tagged corpus can be used to *train* a simple classifier, which can
then be used to guess the tag for untagged words.  For each word, we
can count the number of times it is tagged with each tag.  For
instance, the word ``deal`` is tagged 89 times as ``nn`` and 41 times
as ``vb``.  On this evidence, if we were asked to guess the tag for
``deal`` we would choose ``nn``, and we would be right over two-thirds
of the time.  The following program performs this tagging task, when
trained on the "g" section of the Brown Corpus (so-called *belles
lettres*, creative writing valued for its aesthetic content).

    >>> from nltk_lite.corpora import brown
    >>> cfdist = ConditionalFreqDist()
    >>> for sentence in brown.tagged('g'):
    ...     for token in sentence:
    ...         word = token[0]
    ...         tag = token[1]
    ...         cfdist[word].inc(tag)
    >>> for word in "John saw 3 polar bears".split():
    ...     print word, cfdist[word].max()
    John np
    saw vbd
    3 cd-tl
    polar jj
    bears vbz
    
Note that ``bears`` was incorrectly tagged as the 3rd person singular
form of a verb, since this word appears more frequently as a verb than
a noun in esthetic writing.

A problem with this approach is that it creates a huge model, with an
entry for every possible combination of word and tag.  For certain
tasks it is possible to construct reasonably good models which are
tiny in comparison.  For instance, let's try to guess whether a verb
is a noun or adjective from the last letter of the word alone.  We can
do this as follows:

    >>> tokens = []
    >>> for sent in brown.tagged('g'):
    ...     for (word,tag) in sent:
    ...         if tag in ['nn', 'jj'] and len(word) > 3:
    ...             char = word[-1]
    ...             tokens.append((char,tag))
    >>> split = len(tokens)*9/10
    >>> train, test = tokens[:split], tokens[split:]
    >>> cfdist = ConditionalFreqDist()
    >>> for (char,tag) in train:
    ...     cfdist[char].inc(tag)
    >>> correct = total = 0
    >>> for (char,tag) in test:
    ...     if tag == cfdist[char].max():
    ...         correct += 1
    ...     total += 1
    >>> print correct*100/total
    71

This result of 71% is marginally better than the result of 65% that we
get if we assign the ``nn`` tag to every word.  We can inspect the
model to see which tag is assigned to a word given its final letter.
Here we learn that words which end in ``c`` or ``l`` are more likely
to be adjectives than nouns::

    >>> print [(c, cfdist[c].max()) for c in cfdist.conditions()]
    [('%', 'nn'), ("'", None), ('-', 'jj'), ('2', 'nn'), ('5', 'nn'),
     ('A', 'nn'), ('D', 'nn'), ('O', 'nn'), ('S', 'nn'), ('a', 'nn'),
     ('c', 'jj'), ('b', 'nn'), ('e', 'nn'), ('d', 'nn'), ('g', 'nn'),
     ('f', 'nn'), ('i', 'nn'), ('h', 'nn'), ('k', 'nn'), ('m', 'nn'),
     ('l', 'jj'), ('o', 'nn'), ('n', 'nn'), ('p', 'nn'), ('s', 'nn'),
     ('r', 'nn'), ('u', 'nn'), ('t', 'nn'), ('w', 'nn'), ('y', 'nn'),
     ('x', 'nn'), ('z', 'nn')]

Exercises
---------

#. **Classifying words automatically:**
   The program for classifying words as nouns or adjectives scored 71%.
   Try to come up with better conditions, to get the system to score 80% or better.

   a) Revise the condition to use a longer suffix of the word, such as
      the last two characters, or the last three characters.  What happens
      to the performance?  Which suffixes are diagnostic for adjectives?

   #) Explore other conditions, such as variable length prefixes of a
      word, or the length of a word, or the number of vowels in a word.

   #) Finally, combine multiple conditions into a tuple, and explore
      which combination of conditions gives the best result.

#. **Exploring text genres:**
   Investigate the table of modal distributions and look for other patterns.
   Try to explain them in terms of your own impressionistic understanding
   of the different genres.  Can you find other closed classes of words that
   exhibit significant differences across different genres?

---------------
Further Reading
---------------

.. include:: footer.txt
