.. -*- mode: rst -*-
.. include:: ../definitions.txt

======================
Feature Based Grammar
======================

--------------
 Introduction
--------------




-----------------
Agreement in CFGs
-----------------

The Problem
-----------

Consider the following contrasts:

.. _this:
.. ex::
   .. ex::
      this dog
   .. ex::
      \*these dog

.. _these:
.. ex::
   .. ex::
      these dogs
   .. ex::
      \*this dog

In English, nouns are usually morphologically marked as being singular
or plural. The form of the demonstrative modifier also varies in a
similar way; there is a singular form `this`:lx: and a plural form `these`:lx:.
Examples this_ and these_ show that there are constraints on
the realization of demonstratives and nouns within a noun phrase:
either both are singular or both are plural. A similar kind
of constraint is observed with subjects and predicates:

.. _subjpredsg:
.. ex::
   .. ex::
      the dog runs
   .. ex::
      \*the dog run

.. _subjpredpl:
.. ex::
   .. ex::
      the dogs run
   .. ex::
      \*the dogs runs


Here again, we can see that formal properties of the verb co-vary
with formal properties of the subject noun phrase; this co-variance is
usually termed `agreement`:dt: The element which determines the
agreement, here the subject noun phrase, is called the agreement
`controller`:dt:, while the element whose form is determined by
agreement, here the verb, is called the `target`:dt:.
If we look further at verb agreement in English, we will see that
present tense verbs typically have two inflected forms: one for third person
singular, and another for every other combination of person and
number:

.. ex::
 +--------+--------+--------+
 |        |singular|plural  |
 +--------+--------+--------+
 |1       |run     |run     |
 +--------+--------+--------+
 |2       |run     |run     |
 +--------+--------+--------+
 |3       |runs    |run     |
 +--------+--------+--------+

We can make the role of morphological properties a bit more explicit as
illustrated in runs_ and run_. These representations indicate that the verb agrees with its
subject in person and number.

.. _runs:
.. ex::

 +----------+----------+----------+
 |the       |dog       |run-s     |
 +----------+----------+----------+
 |          |dog.3.SG  |run-3.SG  |
 +----------+----------+----------+


.. _run:
.. ex::

 +------------+------------+------------+
 |the         |dog-s       |run         |
 +------------+------------+------------+
 |            |dog-3.PL    |run.3.PL    |
 +------------+------------+------------+


Despite the undoubted interest of agreement as a topic in its own
right, we have introduced it here for another reason: we want to look
at what happens when  we try encode agreement constraints in a context-free grammar. 
Suppose we take as our starting point the very simple CFG in agcfg0_.

.. _agcfg0:
.. ex::
   .. parsed-literal::

     `S`:gc: |rarr| `NP VP`:gc:
     `NP`:gc: |rarr| `Det N`:gc: 
     `VP`:gc: |rarr| `V`:gc: 

     `Det`:gc: |rarr| 'this'
     `N`:gc: |rarr| 'dog'
     `V`:gc: |rarr| 'runs'

agcfg0_ allows us to generate the sentence `this dog runs`:lx:;
however, what we really want to do is also generate `these dogs
run`:lx: while blocking unwanted strings such as `*this dogs run`:lx:
and `*these dog runs`:lx:. The most straightforward approach is to
add new non-terminals and productions to the grammar which reflect our
number distinctions and agreement constraints (we ignore person for the time being):

.. _agcfg1:
.. ex::
   .. parsed-literal::

     `S_SG`:gc: |rarr| `NP_SG VP_SG`:gc:
     `S_PL`:gc: |rarr| `NP_PL VP_PL`:gc:
     `NP_SG`:gc: |rarr| `Det_SG N_SG`:gc: 
     `NP_PL`:gc: |rarr| `Det_PL N_PL`:gc: 
     `VP_SG`:gc: |rarr| `V_SG`:gc: 
     `VP_PL`:gc: |rarr| `V_PL`:gc: 

     `Det_SG`:gc: |rarr| 'this'
     `Det_PL`:gc: |rarr| 'these'
     `N_SG`:gc: |rarr| 'dog'
     `N_PL`:gc: |rarr| 'dogs'
     `V_SG`:gc: |rarr| 'runs'
     `V_PL`:gc: |rarr| 'run'

It should be clear that this grammar will do the required
task, but only at the cost of duplicating our previous set of
rules. Rule multiplication is of course more severe if we add in
person agreement constraints.

Exercises
---------

#. Augment agcfg1_ so that it will generate strings like `I am
   happy`:lx: and `she is happy`:lx: but not `*you is happy`:lx: or
   `*they am happy`:lx:.

#. Augment agcfg1_ so that it will correctly describe the following
   Spanish noun phrases:

   .. ex::
      .. ex::

	 +---------------------+--------------------+--------------------+
	 |un                   |cuadro              |hermos-o            |
	 +---------------------+--------------------+--------------------+
	 |INDEF.SG.MASC        |picture             |beautiful-SG.MASC   |
	 +---------------------+--------------------+--------------------+
	 |'a beautiful picture'                     |                    |
	 +------------------------------------------+--------------------+

      .. ex::

	 +---------------------+--------------------+--------------------+
	 |un-os                |cuadro-s            |hermos-os           |
	 +---------------------+--------------------+--------------------+
	 |INDEF-PL.MASC        |picture-PL          |beautiful-PL.MASC   |
	 +---------------------+--------------------+--------------------+
	 |'beautiful pictures'                      |                    |
	 +------------------------------------------+--------------------+

      .. ex::

	 +---------------------+--------------------+--------------------+
	 |un-a                 |cortina             |hermos-a            |
	 +---------------------+--------------------+--------------------+
	 |INDEF-SG.FEM         |curtain             |beautiful-SG.FEM    |
	 +---------------------+--------------------+--------------------+
	 |'a beautiful curtain'                     |                    |
	 +------------------------------------------+--------------------+

      .. ex::

	 +---------------------+--------------------+--------------------+
	 |un-as                |cortina-s           |hermos-as           |
	 +---------------------+--------------------+--------------------+
	 |INDEF-PL.FEM         |curtain-PL          |beautiful-SG.FEM    |
	 +---------------------+--------------------+--------------------+
	 |'beautiful curtains'                      |                    |
	 +------------------------------------------+--------------------+

.. In grammatical terms, we might say that both nouns and
   demonstratives have a property of `number`:gc: which can take the values singular or
   plural.


Using Attributes and Constraints
--------------------------------

We spoke informally of linguistic categories having *properties*; for
example, that a verb has the property of being plural. Let's try to
make this more explicit:

.. _num0:
.. ex::
   :: 

     N[num = pl]

In num0_, we have introduced some  new notation which says that the category `N`:gc: has a 
`feature`:dt: called `num`:feat: (short for 'number') and that the
value of this feature is `pl`:fval: (short for 'plural'). We can add
similar notations to other categories, and use them in lexical
entries:

.. _agcfg2:
.. ex::
   .. parsed-literal::

     `Det[num = sg]`:gc: |rarr| 'this'
     `Det[num = pl]`:gc: |rarr| 'these'
     `N[num = sg]`:gc: |rarr| 'dog'
     `N[num = pl]`:gc: |rarr| 'dogs'
     `V[num = sg]`:gc: |rarr| 'runs'
     `V[num = pl]`:gc: |rarr| 'run'

Does this help at all? So far, it looks just like a slightly more
verbose alternative for what we specified in agcfg1_. Things become
more interesting when we allow *variables* over feature values, and use
these to state constraints. This is illustrated in agcfg3_.

.. _agcfg3:
.. ex::
   .. _srule:
   .. ex::
      .. parsed-literal::

        `S`:gc: |rarr| `NP[num = ?n] VP[num = ?n]`:gc:

   .. _nprule:
   .. ex::
      .. parsed-literal::

       `NP[num = ?n]`:gc: |rarr| `Det[num = ?n] N[num = ?n]`:gc: 

   .. _vprule:
   .. ex::
      .. parsed-literal::

       `VP[num = ?n]`:gc: |rarr| `V[num = ?n]`:gc: 

We are using '?n' as a variable over values of `num`:feat:; it can
be instantiated either to `sg`:fval: or `pl`:fval:. Its scope is
limited to individual rules. That is, within srule_, for example,
`?n`:math: must be instantiated to the same constant value; we can
read the rule as saying that whatever value `NP`:gc: takes for the feature
`num`:feat:, `VP`:gc: must take the same value. 

In order to understand how these feature constraints work, it's
helpful to think about how one would go about building a tree. Lexical
rules will admit the following trees:

.. ex::
   .. ex:: 
      .. tree:: (N[num=sg] dog) 
   .. ex:: 
      .. tree:: (N[num=pl] dogs) 
   .. ex:: 
      .. tree:: (Det[num=sg] this) 
   .. ex:: 
      .. tree:: (Det[num=pl] these) 

Now nprule_ says that whatever the `num`:feat: values of `N`:gc: and
`Det`:gc: are, they have to be the same. Consequently, good1_ and good2_
are allowed, but bad1_ and bad2_ are prohibited.

.. ex::
   .. _good1:
   .. ex::
      .. tree:: (NP[num=pl] (Det[num=sg] this)(N[num=sg] dog))

   .. _good2:
   .. ex::
      .. tree:: (NP[num=pl] (Det[num=pl] these)(N[num=pl] dogs))

   .. _bad1:
   .. ex::
      .. tree:: (NP[num=..] (Det[num=sg] this)(N[num=pl] dogs))

   .. _bad2:
   .. ex::
      .. tree:: (NP[num=..] (Det[num=pl] these)(N[num=sg] dog))

Rule vprule_ can be thought of as saying that `num`:feat: value of the
head verb has to the be same as the `num`:feat: value of the `VP`:gc:
daughter. Combined with srule_, we gain the consequence that if the
`num`:feat: value of the subject head noun is `pl`:fval:, then so is
the `num`:feat: value of the `VP`:gc:\ 's head verb.

.. ex::
   .. tree:: (S (NP[num=pl] (Det[num=pl] these)(N[num=pl] dogs))(VP[num=pl] (V[num=pl] run))) 

.. rule proliferation
   loss of generalizations

Case Government
---------------


-------------------------
 Features and Categories
-------------------------

.. brief history
   gpsg, hpsg, lfg

Deconstructing Grammatical Categories
-------------------------------------

.. attribute value pairs
   atomic values
   boolean values
   mention X-bar?

Capturing Constraints in Rules
------------------------------

.. using variables in rules


Unbounded Dependency Constructions
----------------------------------


--------------------------------
 Adding Compositional Semantics
--------------------------------

Overview
--------

The lambda calculus
-------------------

Compositionality
----------------

-----------------
 Further Reading
-----------------



---------
Exercises
---------

1. 


.. include:: footer.txt
